mod common;

use base64::{Engine as _, engine::general_purpose};
use common::{generate_login_request, spawn_app};
use eko_messenger::activitypub::{
    CreateActivity, EncryptedMessage, EncryptedMessageEntry, NoId, WithId, actor_url,
};
use reqwest::Client;
use serde_json::Value;
use std::env;

#[tokio::test]
async fn test_send_and_receive_message_to_self() {
    let app = spawn_app().await;
    let client = Client::new();

    let email = env::var("TEST_USER_EMAIL").expect("TEST_USER_EMAIL not set");
    let password = env::var("TEST_USER_PASSWORD").expect("TEST_USER_PASSWORD not set");

    let login_req = generate_login_request(email.clone(), password.clone());
    let login_url = format!("{}/auth/v1/login", &app.address);

    let login_res = client
        .post(&login_url)
        .header("User-Agent", "test-client")
        .json(&login_req)
        .send()
        .await
        .expect("HTTP Login failed");

    let login_status = login_res.status().as_u16();
    let login_body = login_res.text().await.unwrap();
    assert_eq!(
        login_status, 200,
        "Login failed with status {}: {}",
        login_status, login_body
    );

    let login_json: Value = serde_json::from_str(&login_body).unwrap();
    let auth_token = login_json["accessToken"].as_str().unwrap();
    let uid = login_json["uid"].as_str().unwrap();
    let actor_url = format!("http://{}/users/{}", app.domain, uid);

    let outbox_url = format!("{}/outbox", &actor_url);
    let message_content = "test message to self".to_string();

    let encrypted_message_entry = EncryptedMessageEntry {
        to: 0,
        from: 0,
        content: message_content.as_bytes().to_vec(),
    };

    let encrypted_message = EncryptedMessage::<NoId> {
        context: serde_json::json!([
            "https://www.w3.org/ns/activitystreams",
            "https://w3id.org/security/v1"
        ]),
        type_field: "Note".to_string(),
        id: NoId, // ID will be generated by the server
        content: vec![encrypted_message_entry],
        attributed_to: actor_url.clone(),
        to: vec![actor_url.clone()],
    };

    let outbox_payload = CreateActivity::<NoId> {
        context: Value::String("https://www.w3.org/ns/activitystreams".to_string()),
        type_field: "Create".to_string(),
        id: NoId, // ID will be generated by the server
        actor: actor_url.clone(),
        object: encrypted_message,
    };

    let outbox_res = client
        .post(&outbox_url)
        .bearer_auth(auth_token)
        .header("User-Agent", "test-client")
        .json(&outbox_payload)
        .send()
        .await
        .expect("Failed to send message");

    let outbox_status = outbox_res.status().as_u16();
    let outbox_body = outbox_res.text().await.unwrap();
    assert_eq!(
        outbox_status, 201,
        "Expected CREATED status, got {}: {}",
        outbox_status, outbox_body
    );

    let inbox_url = format!("{}/inbox", actor_url);
    let inbox_res = client
        .get(&inbox_url)
        .bearer_auth(auth_token)
        .header("User-Agent", "test-client")
        .send()
        .await
        .expect("Failed to get inbox");

    let inbox_status = inbox_res.status().as_u16();
    let inbox_body = inbox_res.text().await.unwrap();
    assert_eq!(
        inbox_status, 200,
        "Expected OK status, got {}: {}",
        inbox_status, inbox_body
    );

    let inbox: Vec<Value> = serde_json::from_str(&inbox_body).unwrap();

    assert_eq!(inbox.len(), 1, "Expected 1 message in inbox");
    let received_activity = &inbox[0];
    assert_eq!(
        received_activity["type"], "Create",
        "Activity type mismatch"
    );

    let encrypted_note = &received_activity["object"];
    let message_entries = encrypted_note["content"].as_array().unwrap();
    assert_eq!(message_entries.len(), 1, "Expected 1 message entry");

    let entry_content = message_entries[0]["content"].as_str().unwrap();
    let decoded_content = general_purpose::STANDARD.decode(entry_content).unwrap();

    assert_eq!(
        String::from_utf8(decoded_content).unwrap(),
        message_content,
        "Message content mismatch"
    );
    assert_eq!(
        encrypted_note["attributedTo"],
        format!("http://{}/users/{}", app.domain, uid),
        "AttributedTo mismatch"
    );
}
