mod common;

use base64::{Engine as _, engine::general_purpose};
use common::{generate_login_request, spawn_app};
use eko_messenger::activitypub::{Create, EncryptedMessage, EncryptedMessageEntry};
use eko_messenger::auth::LoginResponse;
use serde_json::Value;

#[tokio::test]
async fn test_send_and_receive_message_to_self() {
    let app = spawn_app().await;
    let client = &app.client;
    let login = app.login_http("user@example.com", "password").await;
    let did = login.did;
    let auth_token = login.access_token;
    let uid = login.uid;
    let actor_url = app.actor_url(&uid);

    let outbox_url = format!("{}/outbox", &actor_url);
    let message_content = "test message to self".to_string();

    let encrypted_message_entry = EncryptedMessageEntry {
        to: did.clone(),
        from: did,
        content: message_content.as_bytes().to_vec(),
    };

    let encrypted_message = EncryptedMessage {
        context: serde_json::json!([
            "https://www.w3.org/ns/activitystreams",
            "https://w3id.org/security/v1"
        ]),
        type_field: "Note".to_string(),
        id: None, // ID will be generated by the server
        content: vec![encrypted_message_entry],
        attributed_to: actor_url.clone(),
        to: vec![actor_url.clone()],
    };

    let outbox_payload = serde_json::json!({
        "type": "Create",
        "@context": "https://www.w3.org/ns/activitystreams",
        "id": null,
        "actor": actor_url,
        "object": encrypted_message,
    });

    let outbox_res = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&outbox_payload)
        .send()
        .await
        .expect("Failed to send message");

    let outbox_status = outbox_res.status().as_u16();
    let outbox_body = outbox_res.text().await.unwrap();
    assert_eq!(
        outbox_status, 201,
        "Expected CREATED status, got {}: {}",
        outbox_status, outbox_body
    );

    let inbox_url = format!("{}/inbox", actor_url);
    let inbox_res = client
        .get(&inbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .send()
        .await
        .expect("Failed to get inbox");

    let inbox_status = inbox_res.status().as_u16();
    let inbox_body = inbox_res.text().await.unwrap();
    assert_eq!(
        inbox_status, 200,
        "Expected OK status, got {}: {}",
        inbox_status, inbox_body
    );

    let inbox: Vec<Value> = serde_json::from_str(&inbox_body).unwrap();

    assert_eq!(inbox.len(), 1, "Expected 1 message in inbox");
    let received_activity = &inbox[0];
    assert_eq!(
        received_activity["type"], "Create",
        "Activity type mismatch"
    );

    let encrypted_note = &received_activity["object"];
    let message_entries = encrypted_note["content"].as_array().unwrap();
    assert_eq!(message_entries.len(), 1, "Expected 1 message entry");

    let entry_content = message_entries[0]["content"].as_str().unwrap();
    let decoded_content = general_purpose::STANDARD.decode(entry_content).unwrap();

    assert_eq!(
        String::from_utf8(decoded_content).unwrap(),
        message_content,
        "Message content mismatch"
    );
    assert_eq!(
        encrypted_note["attributedTo"],
        format!("{}/users/{}", app.domain, uid),
        "AttributedTo mismatch"
    );
}

#[tokio::test]
async fn test_send_message_device_mismatch() {
    let app = spawn_app().await;
    let client = &app.client;

    // --- Recipient (User A) Setup ---
    let user_a_email = "userA@example.com";

    // Register User A - Device 1
    let login_req_a1 = generate_login_request(user_a_email.to_string(), "password".to_string());
    let login_a1 = app
        .login_http(&login_req_a1.email, &login_req_a1.password)
        .await;
    let uid_a = login_a1.uid.clone();
    let did_a1 = login_a1.did;
    let actor_url_a = app.actor_url(&uid_a);

    // Register User A - Device 2 (with a different device name)
    let mut login_req_a2 = generate_login_request(user_a_email.to_string(), "password".to_string());
    login_req_a2.device_name = "test_device_A2".to_string();
    let login_url = format!("{}/auth/v1/login", &app.address);
    let login_res_a2 = client
        .post(&login_url)
        .header("User-Agent", "test-client")
        .json(&login_req_a2)
        .send()
        .await
        .expect("HTTP Login for A2 failed");
    let login_body_a2 = login_res_a2.text().await.unwrap();
    let login_a2: LoginResponse =
        serde_json::from_str(&login_body_a2).expect("Failed to parse login response for A2");
    let did_a2 = login_a2.did; // This is User A's second device ID

    assert_ne!(did_a1, did_a2, "Device IDs for User A should be different");

    // --- Sender (User B) Setup ---
    let user_b_email = "userB@example.com";
    let login_b = app.login_http(user_b_email, "password").await;
    let auth_token_b = login_b.access_token;
    let uid_b = login_b.uid;
    let did_b = login_b.did;

    // --- Construct Malformed Message (encrypted only for Device 1 of User A) ---
    let outbox_url_a = format!("{}/outbox", &actor_url_a);
    let message_content = "secret message for User A".to_string();

    let encrypted_message_entry_for_a1 = EncryptedMessageEntry {
        to: did_a1, // ONLY encrypt for Device 1
        from: did_b,
        content: message_content.as_bytes().to_vec(), // Placeholder content
    };

    let encrypted_message = EncryptedMessage {
        context: serde_json::json!([
            "https://www.w3.org/ns/activitystreams",
            "https://w3id.org/security/v1"
        ]),
        type_field: "EncryptedMessage".to_string(), // Use the correct type
        id: None,
        content: vec![encrypted_message_entry_for_a1], // Intentionally missing did_a2
        attributed_to: app.actor_url(&uid_b),
        to: vec![actor_url_a.clone()], // Recipient actor URL
    };

    let outbox_payload = serde_json::json!({
        "type": "Create",
        "@context": "https://www.w3.org/ns/activitystreams",
        "id": null,
        "actor": app.actor_url(&uid_b),
        "object": encrypted_message,
    });

    // --- Send Request ---
    let outbox_res = client
        .post(&outbox_url_a)
        .bearer_auth(&auth_token_b)
        .header("User-Agent", "test-client")
        .json(&outbox_payload)
        .send()
        .await
        .expect("Failed to send message to recipient's outbox");

    // --- Assert Failure ---
    let outbox_status = outbox_res.status().as_u16();
    let outbox_body = outbox_res.text().await.unwrap();

    assert_eq!(
        outbox_status,
        400, // Expecting Bad Request
        "Expected 400 Bad Request status, got {}: {}",
        outbox_status,
        outbox_body
    );

    // Assert a specific error message
    let error_json: Value =
        serde_json::from_str(&outbox_body).expect("Failed to parse error response body");
    assert_eq!(
        error_json["error"],
        "device_list_mismatch", // Our custom error message
        "Expected 'device_list_mismatch' error, got: {}",
        outbox_body
    );
}

#[tokio::test]
async fn test_take_prekey_bundle_success() {
    let app = spawn_app().await;
    let client = &app.client;

    // Register a user and device
    let login = app.login_http("keyuser@example.com", "password").await;
    let auth_token = login.access_token;
    let uid = login.uid;
    let did = login.did;
    let actor_url = app.actor_url(&uid);

    // Construct the keyCollection URL
    let key_collection_url = format!("{}/devices/{}/keyCollection", &app.domain, did);

    // Create a Take activity
    let take_payload = serde_json::json!({
        "@context": "https://www.w3.org/ns/activitystreams",
        "type": "Take",
        "actor": actor_url,
        "target": key_collection_url,
    });

    // Send the Take request to outbox
    let outbox_url = format!("{}/outbox", &actor_url);
    let res = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send Take request");

    let status = res.status().as_u16();
    let body = res.text().await.unwrap();

    assert_eq!(
        status, 200,
        "Expected 200 OK status, got {}: {}",
        status, body
    );

    // Parse the response as PreKeyBundle
    let bundle: Value = serde_json::from_str(&body).expect("Failed to parse PreKeyBundle");

    // Extract the UUID from the did URL for comparison
    let did_uuid = did.rsplit('/').next().unwrap();

    // Verify all required fields are present
    assert_eq!(
        bundle["did"].as_str().unwrap(),
        did_uuid,
        "Device ID mismatch"
    );
    assert!(
        bundle["preKeyId"].is_number(),
        "preKeyId should be a number"
    );
    assert!(
        bundle["preKey"].is_string(),
        "preKey should be a string (base64)"
    );
    assert!(
        bundle["signedPreKeyId"].is_number(),
        "signedPreKeyId should be a number"
    );
    assert!(
        bundle["signedPreKey"].is_string(),
        "signedPreKey should be a string (base64)"
    );
    assert!(
        bundle["signedPreKeySignature"].is_string(),
        "signedPreKeySignature should be a string (base64)"
    );

    // Verify that identity_key and registration_id are NOT present
    assert!(
        bundle.get("identityKey").is_none(),
        "identityKey should not be in PreKeyBundle"
    );
    assert!(
        bundle.get("registrationId").is_none(),
        "registrationId should not be in PreKeyBundle"
    );
}

#[tokio::test]
async fn test_take_invalid_target_url() {
    let app = spawn_app().await;
    let client = &app.client;

    let login = app.login_http("invaliduser@example.com", "password").await;
    let auth_token = login.access_token;
    let uid = login.uid;
    let did = login.did;
    let actor_url = app.actor_url(&uid);

    // Create a Take activity with invalid target (missing /keyCollection)
    let invalid_target = format!("{}/devices/{}", &app.domain, did);
    let take_payload = serde_json::json!({
        "@context": "https://www.w3.org/ns/activitystreams",
        "type": "Take",
        "actor": actor_url,
        "target": invalid_target,
    });

    let outbox_url = format!("{}/outbox", &actor_url);
    let res = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send Take request");

    let status = res.status().as_u16();
    let body = res.text().await.unwrap();

    assert_eq!(
        status, 400,
        "Expected 400 Bad Request status, got {}: {}",
        status, body
    );
}

#[tokio::test]
async fn test_take_nonexistent_device() {
    use uuid::Uuid;

    let app = spawn_app().await;
    let client = &app.client;

    let login = app.login_http("requester@example.com", "password").await;
    let auth_token = login.access_token;
    let uid = login.uid;
    let actor_url = app.actor_url(&uid);

    // Create a random device ID that doesn't exist
    let nonexistent_did = Uuid::new_v4();
    let key_collection_url = format!("{}/devices/{}/keyCollection", &app.domain, nonexistent_did);

    let take_payload = serde_json::json!({
        "@context": "https://www.w3.org/ns/activitystreams",
        "type": "Take",
        "actor": actor_url,
        "target": key_collection_url,
    });

    let outbox_url = format!("{}/outbox", &actor_url);
    let res = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send Take request");

    let status = res.status().as_u16();
    let body = res.text().await.unwrap();

    assert_eq!(
        status, 404,
        "Expected 404 Not Found status, got {}: {}",
        status, body
    );
}

#[tokio::test]
async fn test_take_last_prekey_is_reusable() {
    let app = spawn_app().await;
    let client = &app.client;

    // Register user with device (gets 1 prekey from default login)
    let login = app.login_http("lastkey@example.com", "password").await;
    let auth_token = login.access_token;
    let uid = login.uid;
    let did = login.did;
    let actor_url = app.actor_url(&uid);

    let key_collection_url = format!("{}/devices/{}/keyCollection", &app.domain, did);
    let outbox_url = format!("{}/outbox", &actor_url);

    // Make the first request (should consume the prekey if there were multiple)
    let take_payload = serde_json::json!({
        "@context": "https://www.w3.org/ns/activitystreams",
        "type": "Take",
        "actor": actor_url,
        "target": key_collection_url,
    });

    let res1 = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send first Take request");

    assert_eq!(res1.status().as_u16(), 200, "First request should succeed");
    let bundle1: Value = serde_json::from_str(&res1.text().await.unwrap()).unwrap();

    // Make a second request (should return the same prekey since it's the last one)
    let res2 = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send second Take request");

    assert_eq!(
        res2.status().as_u16(),
        200,
        "Second request should succeed with last prekey"
    );
    let bundle2: Value = serde_json::from_str(&res2.text().await.unwrap()).unwrap();

    // Verify both bundles have the same preKeyId (since only one exists)
    assert_eq!(
        bundle1["preKeyId"], bundle2["preKeyId"],
        "Last prekey should be reused"
    );

    // Make a third request to be sure
    let res3 = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send third Take request");

    assert_eq!(
        res3.status().as_u16(),
        200,
        "Third request should also succeed"
    );
}

#[tokio::test]
async fn test_take_unauthenticated_request_fails() {
    use uuid::Uuid;

    let app = spawn_app().await;
    let client = &app.client;

    // Create a user to get a valid device ID
    let login = app.login_http("authtest@example.com", "password").await;
    let uid = login.uid;
    let did = login.did;
    let actor_url = app.actor_url(&uid);

    let key_collection_url = format!("{}/devices/{}/keyCollection", &app.domain, did);

    let take_payload = serde_json::json!({
        "@context": "https://www.w3.org/ns/activitystreams",
        "type": "Take",
        "actor": actor_url,
        "target": key_collection_url,
    });

    let outbox_url = format!("{}/outbox", &actor_url);

    // Send request WITHOUT bearer auth
    let res = client
        .post(&outbox_url)
        .header("User-Agent", "test-client")
        .json(&take_payload)
        .send()
        .await
        .expect("Failed to send unauthenticated Take request");

    let status = res.status().as_u16();

    // Should be rejected by auth middleware
    assert_eq!(
        status, 401,
        "Unauthenticated request should return 401 Unauthorized"
    );
}
