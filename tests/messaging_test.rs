mod common;

use base64::{Engine as _, engine::general_purpose};
use common::spawn_app;
use eko_messenger::activitypub::{CreateActivity, EncryptedMessage, EncryptedMessageEntry, NoId};
use serde_json::Value;

#[tokio::test]
async fn test_send_and_receive_message_to_self() {
    let app = spawn_app().await;
    let client = &app.client;
    let login = app.login_http("user@example.com", "password").await;
    let did = login.did;
    let auth_token = login.access_token;
    let uid = login.uid;
    let actor_url = app.actor_url(&uid);

    let outbox_url = format!("{}/outbox", &actor_url);
    let message_content = "test message to self".to_string();

    let encrypted_message_entry = EncryptedMessageEntry {
        to: did,
        from: did,
        content: message_content.as_bytes().to_vec(),
    };

    let encrypted_message = EncryptedMessage::<NoId> {
        context: serde_json::json!([
            "https://www.w3.org/ns/activitystreams",
            "https://w3id.org/security/v1"
        ]),
        type_field: "Note".to_string(),
        id: NoId, // ID will be generated by the server
        content: vec![encrypted_message_entry],
        attributed_to: actor_url.clone(),
        to: vec![actor_url.clone()],
    };

    let outbox_payload = CreateActivity::<NoId> {
        context: Value::String("https://www.w3.org/ns/activitystreams".to_string()),
        type_field: "Create".to_string(),
        id: NoId, // ID will be generated by the server
        actor: actor_url.clone(),
        object: encrypted_message,
    };

    let outbox_res = client
        .post(&outbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .json(&outbox_payload)
        .send()
        .await
        .expect("Failed to send message");

    let outbox_status = outbox_res.status().as_u16();
    let outbox_body = outbox_res.text().await.unwrap();
    assert_eq!(
        outbox_status, 201,
        "Expected CREATED status, got {}: {}",
        outbox_status, outbox_body
    );

    let inbox_url = format!("{}/inbox", actor_url);
    let inbox_res = client
        .get(&inbox_url)
        .bearer_auth(&auth_token)
        .header("User-Agent", "test-client")
        .send()
        .await
        .expect("Failed to get inbox");

    let inbox_status = inbox_res.status().as_u16();
    let inbox_body = inbox_res.text().await.unwrap();
    assert_eq!(
        inbox_status, 200,
        "Expected OK status, got {}: {}",
        inbox_status, inbox_body
    );

    let inbox: Vec<Value> = serde_json::from_str(&inbox_body).unwrap();

    assert_eq!(inbox.len(), 1, "Expected 1 message in inbox");
    let received_activity = &inbox[0];
    assert_eq!(
        received_activity["type"], "Create",
        "Activity type mismatch"
    );

    let encrypted_note = &received_activity["object"];
    let message_entries = encrypted_note["content"].as_array().unwrap();
    assert_eq!(message_entries.len(), 1, "Expected 1 message entry");

    let entry_content = message_entries[0]["content"].as_str().unwrap();
    let decoded_content = general_purpose::STANDARD.decode(entry_content).unwrap();

    assert_eq!(
        String::from_utf8(decoded_content).unwrap(),
        message_content,
        "Message content mismatch"
    );
    assert_eq!(
        encrypted_note["attributedTo"],
        format!("{}/users/{}", app.domain, uid),
        "AttributedTo mismatch"
    );
}
